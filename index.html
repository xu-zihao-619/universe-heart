<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>universe-heart</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }
        
        body {
            background: black;
            overflow: hidden;
        }
        
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        
        /* 文本样式 */
        #centerText {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 192, 203, 0.9);
            font-family: 'Arial', sans-serif;
            font-size: 48px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 192, 203, 0.8), 
                         0 0 20px rgba(255, 192, 203, 0.6),
                         0 0 30px rgba(255, 192, 203, 0.4);
            pointer-events: none; /* 让鼠标事件穿透文本层 */
            z-index: 10;
        }
    </style>
</head>
<body>
    <canvas id="heartCanvas"></canvas>
    <div id="centerText">universe</div>

    <script>
        // 获取Canvas元素和上下文
        const canvas = document.getElementById('heartCanvas');
        const ctx = canvas.getContext('2d');
        
        // 全局配置 - 爱心适当放大
        let CANVAS_WIDTH, CANVAS_HEIGHT, CANVAS_CENTER_X, CANVAS_CENTER_Y;
        const IMAGE_ENLARGE = 14;  // 从11调整到14，适当放大爱心
        const HEART_COLOR = 'pink'; // 保持Python原版颜色
        
        // 设置Canvas尺寸（填满窗口）
        function resizeCanvas() {
            // 获取窗口实际尺寸
            CANVAS_WIDTH = window.innerWidth;
            CANVAS_HEIGHT = window.innerHeight;
            
            // 设置Canvas分辨率匹配窗口
            canvas.width = CANVAS_WIDTH;
            canvas.height = CANVAS_HEIGHT;
            
            // 计算中心坐标
            CANVAS_CENTER_X = CANVAS_WIDTH / 2;
            CANVAS_CENTER_Y = CANVAS_HEIGHT / 2;
            
            // 重新创建爱心实例以适应新尺寸
            if (typeof heart !== 'undefined') {
                heart = new Heart();
            }
        }
        
        // 监听窗口大小变化
        window.addEventListener('resize', resizeCanvas);
        
        // ==================== 保持Python原版算法不变 ====================
        // 爱心函数生成器（完全复刻Python）
        function heart_function(t, shrink_ratio = IMAGE_ENLARGE) {
            const x = 16 * Math.pow(Math.sin(t), 3);
            const y = -(13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
            
            // 放大和居中
            const scaledX = x * shrink_ratio + CANVAS_CENTER_X;
            const scaledY = y * shrink_ratio + CANVAS_CENTER_Y;
            
            return { x: Math.round(scaledX), y: Math.round(scaledY) };
        }
        
        // 随机内部扩散（完全复刻Python）
        function scatter_inside(x, y, beta = 0.15) {
            const ratio_x = -beta * Math.log(Math.random());
            const ratio_y = -beta * Math.log(Math.random());
            
            const dx = ratio_x * (x - CANVAS_CENTER_X);
            const dy = ratio_y * (y - CANVAS_CENTER_Y);
            
            return { x: x - dx, y: y - dy };
        }
        
        // 抖动效果（完全复刻Python）
        function shrink(x, y, ratio) {
            const denominator = Math.pow(Math.pow(x - CANVAS_CENTER_X, 2) + Math.pow(y - CANVAS_CENTER_Y, 2), 0.6);
            const force = -1 / denominator;
            
            const dx = ratio * force * (x - CANVAS_CENTER_X);
            const dy = ratio * force * (y - CANVAS_CENTER_Y);
            
            return { x: x - dx, y: y - dy };
        }
        
        // 自定义曲线函数（完全复刻Python）
        function curve(p) {
            return 4 * (2 * Math.sin(4 * p)) / (2 * Math.PI);
        }
        
        // ==================== 爱心类保持Python原版逻辑 ====================
        class Heart {
            constructor(generate_frame = 20) {
                this._points = new Set();          // 原始爱心坐标集合
                this._edge_diffusion_points = new Set(); // 边缘扩散效果点
                this._center_diffusion_points = new Set(); // 中心扩散效果点
                this.all_points = {};             // 每帧动态点坐标
                this.generate_frame = generate_frame;
                
                // 保持Python原版参数
                this.build(2000); // 保持2000个点
                
                // 预计算所有帧
                for (let frame = 0; frame < generate_frame; frame++) {
                    this.calc(frame);
                }
            }
            
            build(number) {
                // 生成原始爱心点
                for (let i = 0; i < number; i++) {
                    const t = Math.random() * 2 * Math.PI;
                    const point = heart_function(t);
                    const key = `${point.x},${point.y}`;
                    this._points.add(key);
                }
                
                // 爱心内扩散（边缘）- 保持Python原版逻辑
                const pointsArray = Array.from(this._points);
                for (const key of pointsArray) {
                    const [x, y] = key.split(',').map(Number);
                    for (let i = 0; i < 3; i++) {
                        const newPoint = scatter_inside(x, y, 0.05);
                        const newKey = `${Math.round(newPoint.x)},${Math.round(newPoint.y)}`;
                        this._edge_diffusion_points.add(newKey);
                    }
                }
                
                // 爱心内再次扩散（中心）- 保持Python原版4000个点
                for (let i = 0; i < 4000; i++) {
                    const randomKey = pointsArray[Math.floor(Math.random() * pointsArray.length)];
                    const [x, y] = randomKey.split(',').map(Number);
                    const newPoint = scatter_inside(x, y, 0.17);
                    const newKey = `${Math.round(newPoint.x)},${Math.round(newPoint.y)}`;
                    this._center_diffusion_points.add(newKey);
                }
            }
            
            calc_position(x, y, ratio) {
                // 保持Python原版计算逻辑
                const denominator = Math.pow(Math.pow(x - CANVAS_CENTER_X, 2) + Math.pow(y - CANVAS_CENTER_Y, 2), 0.520);
                const force = 1 / denominator;
                
                const dx = ratio * force * (x - CANVAS_CENTER_X) + (Math.random() > 0.5 ? 1 : -1);
                const dy = ratio * force * (y - CANVAS_CENTER_Y) + (Math.random() > 0.5 ? 1 : -1);
                
                return { x: x - dx, y: y - dy };
            }
            
            calc(generate_frame) {
                // 保持Python原版计算逻辑
                const ratio = 10 * curve(generate_frame / 10 * Math.PI);
                const halo_radius = Math.floor(4 + 6 * (1 + curve(generate_frame / 10 * Math.PI)));
                const halo_number = Math.floor(3000 + 4000 * Math.pow(Math.abs(curve(generate_frame / 10 * Math.PI)), 2));
                
                const all_points = [];
                
                // 光环效果 - 保持Python原版逻辑（光环也相应放大）
                const heart_halo_point = new Set();
                for (let i = 0; i < halo_number; i++) {
                    const t = Math.random() * 2 * Math.PI;
                    let point = heart_function(t, 14); // 光环也从11调整到14
                    point = shrink(point.x, point.y, halo_radius);
                    
                    const key = `${Math.round(point.x)},${Math.round(point.y)}`;
                    if (!heart_halo_point.has(key)) {
                        heart_halo_point.add(key);
                        point.x += Math.floor(Math.random() * 22 - 11); // -11 到 11
                        point.y += Math.floor(Math.random() * 22 - 11);
                        const size = [1, 2, 2][Math.floor(Math.random() * 3)]; // 保持Python原版
                        all_points.push({ x: point.x, y: point.y, size });
                    }
                }
                
                // 轮廓点 - 保持Python原版逻辑
                for (const key of this._points) {
                    const [x, y] = key.split(',').map(Number);
                    const newPoint = this.calc_position(x, y, ratio);
                    const size = Math.floor(Math.random() * 3) + 1; // 1-3
                    all_points.push({ 
                        x: Math.round(newPoint.x), 
                        y: Math.round(newPoint.y), 
                        size 
                    });
                }
                
                // 中心点 - 保持Python原版逻辑
                for (const key of this._center_diffusion_points) {
                    const [x, y] = key.split(',').map(Number);
                    const newPoint = this.calc_position(x, y, ratio);
                    const size = Math.floor(Math.random() * 2) + 1; // 1-2
                    all_points.push({ 
                        x: Math.round(newPoint.x), 
                        y: Math.round(newPoint.y), 
                        size 
                    });
                }
                
                this.all_points[generate_frame] = all_points;
            }
            
            render(render_frame) {
                // 清空整个画布
                ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                
                // 获取当前帧的所有点
                const framePoints = this.all_points[render_frame % this.generate_frame] || [];
                
                // 设置Python原版颜色
                ctx.fillStyle = HEART_COLOR;
                
                // 绘制所有点 - 保持Python原版方式
                for (const point of framePoints) {
                    ctx.fillRect(point.x, point.y, point.size, point.size);
                }
            }
        }
        
        // ==================== 动画控制保持Python原版节奏 ====================
        let heart;
        let frame = 0;
        
        // 初始化
        function init() {
            resizeCanvas();
            heart = new Heart();
            
            // 开始动画循环 - 保持Python原版160ms间隔
            animate();
        }
        
        // 动画循环 - 保持Python原版帧率
        function animate() {
            if (heart) {
                heart.render(frame);
                frame++;
            }
            
            // 保持Python原版的160ms延迟
            setTimeout(() => {
                requestAnimationFrame(animate);
            }, 160);
        }
        
        // 页面加载完成后初始化
        window.addEventListener('load', init);
    </script>
</body>
</html>